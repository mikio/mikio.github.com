<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>clojure</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="clojure"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2012-02-17 20:08:20 JST"/>
<meta name="author" content=""/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">clojure</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 clojureで最初に覚えるべきこと</a></li>
<li><a href="#sec-2">2 4clojure</a>
<ul>
<li><a href="#sec-2-1">2.1 Lists: conj</a></li>
<li><a href="#sec-2-2">2.2 Intro to Vectors</a></li>
</ul>
</li>
<li><a href="#sec-3">3 repl</a>
<ul>
<li><a href="#sec-3-1">3.1 clojureのバージョンを得る。</a></li>
<li><a href="#sec-3-2">3.2 現在読み込まれているライブラリのリストを取得する。</a></li>
<li><a href="#sec-3-3">3.3 classpathを取得する。</a></li>
<li><a href="#sec-3-4">3.4 ソースを確認する</a></li>
<li><a href="#sec-3-5">3.5 Javaのメンバを確認する</a></li>
<li><a href="#sec-3-6">3.6 名前空間を移動する。</a></li>
</ul>
</li>
<li><a href="#sec-4">4 一章</a></li>
<li><a href="#sec-5">5 オンラインドキュメント調べ物</a></li>
<li><a href="#sec-6">6 名前空間</a>
<ul>
<li><a href="#sec-6-1">6.1 requireとuse</a></li>
<li><a href="#sec-6-2">6.2 複数指定する方法</a></li>
<li><a href="#sec-6-3">6.3 only</a>
<ul>
<li><a href="#sec-6-3-1">6.3.1 ちょっとコラムw</a></li>
</ul>
</li>
<li><a href="#sec-6-4">6.4 nsマクロ</a></li>
<li><a href="#sec-6-5">6.5 </a></li>
</ul>
</li>
<li><a href="#sec-7">7 slime</a></li>
<li><a href="#sec-8">8 switch-caseの代替(複数分岐)</a></li>
<li><a href="#sec-9">9 正規表現</a></li>
<li><a href="#sec-10">10 use</a></li>
<li><a href="#sec-11">11 lein</a>
<ul>
<li><a href="#sec-11-1">11.1 実行形式のファイルにする</a></li>
</ul>
</li>
<li><a href="#sec-12">12 Tips</a>
<ul>
<li><a href="#sec-12-1">12.1 ファイルの読み出し</a></li>
</ul>
</li>
<li><a href="#sec-13">13 ドキュメントを見る</a></li>
<li><a href="#sec-14">14 JAVA</a>
<ul>
<li><a href="#sec-14-1">14.1 インポート</a></li>
<li><a href="#sec-14-2">14.2 javaとの連携方法</a></li>
<li><a href="#sec-14-3">14.3 javaのインターフェイスを実装する方法</a></li>
</ul>
</li>
<li><a href="#sec-15">15 リーダーマクロ</a></li>
<li><a href="#sec-16">16 変数の変更</a></li>
<li><a href="#sec-17">17 ライブラリのロード</a></li>
<li><a href="#sec-18">18 真偽</a></li>
<li><a href="#sec-19">19 マップ</a></li>
<li><a href="#sec-20">20 関数</a>
<ul>
<li><a href="#sec-20-1">20.1 無名関数</a>
<ul>
<li><a href="#sec-20-1-1">20.1.1 はまり</a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-21">21 束縛</a>
<ul>
<li><a href="#sec-21-1">21.1 ひとこと</a></li>
</ul>
</li>
<li><a href="#sec-22">22 分配束縛</a></li>
<li><a href="#sec-23">23 シーケンス</a>
<ul>
<li><a href="#sec-23-1">23.1 指定した番目の要素を取得する。</a></li>
<li><a href="#sec-23-2">23.2 変換</a>
<ul>
<li><a href="#sec-23-2-1">23.2.1 map</a></li>
<li><a href="#sec-23-2-2">23.2.2 reduce</a></li>
<li><a href="#sec-23-2-3">23.2.3 sort, sort-by</a></li>
<li><a href="#sec-23-2-4">23.2.4 for</a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-24">24 実践例</a>
<ul>
<li><a href="#sec-24-1">24.1 ある文字列の値を足しこむ関数</a></li>
<li><a href="#sec-24-2">24.2 みんな大好きfizzbuzz</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> clojureで最初に覚えるべきこと</h2>
<div class="outline-text-2" id="text-1">

<p><a href="http://d.hatena.ne.jp/omasanori/20110928/1317189094">http://d.hatena.ne.jp/omasanori/20110928/1317189094</a>
</p>



<pre class="src src-sh">&#22987;&#12417;&#12427;&#21069;&#12395;
omasanori

Clojure&#12434;&#23398;&#12406;&#32773;&#12399;&#12289;doc&#12398;&#23384;&#22312;&#12434;&#12394;&#12427;&#12409;&#12367;&#26089;&#12367;&#30693;&#12387;&#12383;&#26041;&#12364;&#12356;&#12356;&#12290;
&#12302;&#12503;&#12525;&#12464;&#12521;&#12511;&#12531;&#12464;Clojure&#12303;&#12399;&#12289;doc&#12434;19&#12506;&#12540;&#12472;&#12391;&#25945;&#12360;&#12289;&#22235;&#21063;&#28436;&#31639;&#12434;27&#12506;&#12540;&#12472;&#12391;&#25945;&#12360;&#12427;&#12290;
&#20351;&#12356;&#26041;&#12434;&#30693;&#12425;&#12394;&#12356;&#38306;&#25968;&#12434;&#35211;&#12363;&#12369;&#12383;&#12425;&#12289;&#26368;&#21021;&#12395;&#35338;&#12397;&#12427;&#12409;&#12365;&#30456;&#25163;&#12399;Google&#12391;&#12399;&#12394;&#12367;&#12289;doc&#12384; <span class="org-comment-delimiter">#</span><span class="org-comment">clojure</span>
2011-09-22 14:32:25 via &#12514;&#12496;&#12484;&#12452; / www.movatwi.jp .
omasanori

doc&#12392;&#21516;&#12376;&#38915;&#12395;source&#12418;&#30693;&#12427;&#12371;&#12392;&#12364;&#12391;&#12365;&#12428;&#12400;&#12394;&#12362;&#33391;&#12356;&#12364;&#12289;&#33258;&#20998;&#12391;&#38306;&#25968;&#12434;&#26360;&#12367;&#12424;&#12358;&#12395;&#12394;&#12387;&#12383;&#38915;&#12391;&#12418;&#33391;&#12356;&#12392;&#31169;&#12399;&#24605;&#12358;&#12290;
&#12302;&#12503;&#12525;&#12464;&#12521;&#12511;&#12531;&#12464;Clojure&#12303;&#12391;&#12399;20&#12506;&#12540;&#12472;&#12290;
&#20351;&#12356;&#24931;&#12428;&#12383;&#38306;&#25968;&#12398;&#20013;&#36523;&#12434;&#30693;&#12426;&#12383;&#12356;&#12392;&#24605;&#12387;&#12383;&#26178;&#12289;git clone&#12398;&#21069;&#12395;source&#12434;&#20351;&#12358;&#12424;&#12358;&#12395;&#12394;&#12387;&#12390;&#12362;&#12365;&#12383;&#12356; <span class="org-comment-delimiter">#</span><span class="org-comment">clojure</span>
2011-09-22 14:51:58 via &#12514;&#12496;&#12484;&#12452; / www.movatwi.jp .
omasanori

&#27096;&#12293;&#12394;&#20107;&#26564;&#12434;&#23398;&#12435;&#12384;&#38915;&#12395;find-doc&#12392;apropos&#12434;&#30693;&#12387;&#12390;&#12356;&#12428;&#12400;&#12289;
&#12393;&#12371;&#12363;&#12395;&#12354;&#12427;&#12371;&#12392;&#12434;&#30693;&#12387;&#12390;&#12356;&#12427;&#12398;&#12395;&#24605;&#12356;&#20986;&#12379;&#12394;&#12356;&#26178;&#12420;&#12289;
&#12393;&#12371;&#12363;&#12395;&#12354;&#12427;&#12363;&#12393;&#12358;&#12363;&#30693;&#12426;&#12383;&#12356;&#26178;&#12395;&#12289;Google&#12424;&#12426;&#20808;&#12395;&#35338;&#12397;&#12427;&#12371;&#12392;&#12364;&#12391;&#12365;&#12427; <span class="org-comment-delimiter">#</span><span class="org-comment">clojure</span>
2011-09-22 14:59:13 via &#12514;&#12496;&#12484;&#12452; / www.movatwi.jp .

&#35299;&#35500;&#12375;&#12390;&#12394;&#12356;&#37096;&#20998;&#12399;doc&#12434;&#20351;&#12387;&#12390;&#35519;&#12409;&#12390;&#12289;&#30097;&#21839;&#12364;&#27531;&#12387;&#12390;&#12356;&#12383;&#12425;&#27671;&#36605;&#12395;&#36074;&#21839;&#12375;&#12390;&#12367;&#12384;&#12373;&#12356;&#12290;

Google&#12424;&#12426;&#20808;&#12395;&#35338;&#12397;&#12427;&#12371;&#12392;&#12364;&#12391;&#12365;&#12427;
</pre>



</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 4clojure</h2>
<div class="outline-text-2" id="text-2">


</div>

<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> Lists: conj</h3>
<div class="outline-text-3" id="text-2-1">

<p>conjは引数を順番にlistの先頭にくっつけていく。
user&gt; (conj '(2 3 4) 1)
(1 2 3 4)
user&gt; (conj '(3 4) 1 2)
(2 1 3 4)
</p>
</div>

</div>

<div id="outline-container-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> Intro to Vectors</h3>
<div class="outline-text-3" id="text-2-2">

<p> (= [_<sub>]</sub> (list :a :b :c) (vec '(:a :b :c)) (vector :a :b :c))
</p>

<p>
 (= [:a :b :c] (list :a :b :c) (vec '(:a :b :c)) (vector :a :b :c))
</p>


<p>
リストをベクタに変換する
</p>


<pre class="src src-sh">user&gt; (vec <span class="org-string">'(:a :b :c))</span>
<span class="org-string">[:a :b :c]</span>
</pre>


<p>
ベクタを作る
</p>


<pre class="src src-sh">user&gt; (vector :a :b :c)
[:a :b :c]
</pre>


<p>
それぞれの返り値がベクタなので最初わからなかったが
REPLに入れたらtrueが帰ってきた！
</p>


<pre class="src src-sh">user&gt;  (= [:a :b :c] (list :a :b :c) (vec <span class="org-string">'(:a :b :c)) (vector :a :b :c))</span>
<span class="org-string">true</span>
</pre>

<p>
= 関数は中身だけ見るのね。
</p>

<p>
user&gt;  (= [:a :b :c] (list :a :b :c) (vec '(:a :b :c)) (vector :a :b :c))
</p>
<p>
'[:a :b :c]
</p>


</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> repl</h2>
<div class="outline-text-2" id="text-3">


</div>

<div id="outline-container-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> clojureのバージョンを得る。</h3>
<div class="outline-text-3" id="text-3-1">

<p>(clojure-version)
</p>
</div>

</div>

<div id="outline-container-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> 現在読み込まれているライブラリのリストを取得する。</h3>
<div class="outline-text-3" id="text-3-2">

<p>(loaded-libs)
</p>
</div>

</div>

<div id="outline-container-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> classpathを取得する。</h3>
<div class="outline-text-3" id="text-3-3">

<p>(use 'clojure.contrib.classpath)
(classpath)
</p>
</div>

</div>

<div id="outline-container-3-4" class="outline-3">
<h3 id="sec-3-4"><span class="section-number-3">3.4</span> ソースを確認する</h3>
<div class="outline-text-3" id="text-3-4">

<p>p20
(use 'clojure.contrib.repl-utils)
(source str*); -&gt; (defn str* &hellip;)
</p>
</div>

</div>

<div id="outline-container-3-5" class="outline-3">
<h3 id="sec-3-5"><span class="section-number-3">3.5</span> Javaのメンバを確認する</h3>
<div class="outline-text-3" id="text-3-5">

<p>p21
(use 'clojure.contrib.repl-utils)
(show java.util.HashMap)
</p></div>

</div>

<div id="outline-container-3-6" class="outline-3">
<h3 id="sec-3-6"><span class="section-number-3">3.6</span> 名前空間を移動する。</h3>
<div class="outline-text-3" id="text-3-6">

<p>(in-ns 'hello-cube.core)
</p>

</div>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> 一章</h2>
<div class="outline-text-2" id="text-4">

<p>"*1", "*2", "*e"は特別な変数。
</p>

<p>
 #{}
  setノリテラル
</p>
<p>
 conj
  conjは結合するの意味(conjoinの短縮形)
</p>
<p>
 ref
  リファレンス。変更可能な値を定義
</p>
<p>
 alter
  refで宣言した値の更新
</p>
<p>
 dosync
  トランザクション
</p>
<p>
 リファレンスを更新する例
   (dosync (alter visitors conj "Mikio"))
</p>


</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> オンラインドキュメント調べ物</h2>
<div class="outline-text-2" id="text-5">

<p>既にnamespaceがrequireされているか調べるにはfind-nsで探せば良いです。
</p>


<pre class="src src-sh">(find-ns <span class="org-string">'clojure.contrib.duck-streams) ; =&gt; nil</span>
<span class="org-string">(require '</span>clojure.contrib.duck-streams)
(find-ns <span class="org-string">'clojure.contrib.duck-streams) ; =&gt; #&lt;Namespace clojure.contrib.duck-streams&gt;</span>
</pre>


<p>
以下のようにすればuseもしくはimportしたnamespaceで定義された関数などが見れます。
</p>


<pre class="src src-sh">(keys (ns-interns <span class="org-string">'clojure.contrib.duck-streams))</span>
<span class="org-string">;;reader&#12364;&#12354;&#12428;&#12400;writer&#12418;&#12354;&#12427;&#12398;&#12391;&#12375;&#12423;&#12358;&#12363;&#65311;</span>
<span class="org-string">(some #{'</span>writer} (keys (ns-interns <span class="org-string">'clojure.contrib.duck-streams))) ; =&gt; writer</span>
</pre>



</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> 名前空間</h2>
<div class="outline-text-2" id="text-6">



</div>

<div id="outline-container-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> requireとuse</h3>
<div class="outline-text-3" id="text-6-1">

<p>requireは完全修飾名で名前を指定する必要がある。
useは関数名だけでよい。
</p>



<pre class="src src-sh">;; &#12459;&#12524;&#12531;&#12488;&#21517;&#21069;&#31354;&#38291;&#12395; clojure.pprint (clojure1.1&#12391;&#12399; clojure.contrib.pprint)
;; &#12391;&#23450;&#32681;&#12373;&#12428;&#12390;&#12356;&#12427;&#38306;&#25968;&#12420;&#22793;&#25968;&#12434;&#23566;&#20837;
(use <span class="org-string">'clojure.pprint)</span>
<span class="org-string">(pprint *clojure-version*)</span>

<span class="org-string">;; clojure.pprint &#21517;&#21069;&#31354;&#38291;&#12434;&#25351;&#23450;&#12375;&#12390;&#12514;&#12472;&#12517;&#12540;&#12523;&#12434;&#35501;&#12415;&#36796;&#12416;</span>
<span class="org-string">(require '</span>clojure.pprint)
(clojure.pprint/pprint *clojure-version*)       
</pre>


<p>
require (と use) は複数の名前空間をとることが出来ます。
</p>
</div>

</div>

<div id="outline-container-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> 複数指定する方法</h3>
<div class="outline-text-3" id="text-6-2">

<p>すなおな方法。
</p>


<pre class="src src-sh">(require <span class="org-string">'clojure.contrib.classpath)</span>
<span class="org-string">(require '</span>clojure.contrib.macro-utils)
&#8595;
(require <span class="org-string">'clojure.contrib.classpath</span>
<span class="org-string">         '</span>clojure.contrib.macro-utils)
</pre>


<p>
共通する部分をまとめて指定する方法。
</p>


<pre class="src src-sh">(require <span class="org-string">'(clojure.contrib classpath macro-utils)) </span>
</pre>

<p>
共通部を最初の要素としたリストを渡す。
これは人の名前空間でもできる。
</p>


<pre class="src src-sh">(require <span class="org-string">'(clojure.contrib classpath macro-utils)) </span>
</pre>




</div>

</div>

<div id="outline-container-6-3" class="outline-3">
<h3 id="sec-6-3"><span class="section-number-3">6.3</span> only</h3>
<div class="outline-text-3" id="text-6-3">

<p>only節は使用したい関数のみを指定する方法。
この時名前空間はベクタで渡し、:onli以降の関数はリストで渡す。'は必要ない。
</p>


<pre class="src src-sh">;; pprint&#38306;&#25968; &#12392; pp&#38306;&#25968; &#12398;&#20108;&#12388;&#12384;&#12369;&#12434;&#21442;&#29031;
(use <span class="org-string">'[clojure.pprint :only (pprint pp)])</span>
</pre>



</div>

<div id="outline-container-6-3-1" class="outline-4">
<h4 id="sec-6-3-1"><span class="section-number-4">6.3.1</span> ちょっとコラムw</h4>
<div class="outline-text-4" id="text-6-3-1">

<p>:only節がいまいちわかりずらいが(:only (pprint pp))みたいな
関数として渡したくなる。:onlyは関数ではなく、素の外側のベクタの
要素であると考えよう。use関数が与えられたベクタの要素を順番に走査していったときに
:onlyがでたら直後の要素をonly関数として理解していると想像しよう。
</p>
<p>
ちなみにrequireとuseに渡す名前空間はベクタでもリストでよいらしい。
</p>


<pre class="src src-sh">;; &#25324;&#24359;&#12399;&#33258;&#30001;
(require <span class="org-string">'(strike-witches (eila-ilmatar-juutilainen :as eila)))</span>
<span class="org-string">(require '</span>[strike-witches (eila-ilmatar-juutilainen :as eila)])
(require <span class="org-string">'(strike-witches [eila-ilmatar-juutilainen :as eila]))</span>
<span class="org-string">(require '</span>[strike-witches [eila-ilmatar-juutilainen :as eila]])
;;&#12393;&#12428;&#12391;&#12418; OK
</pre>


</div>
</div>

</div>

<div id="outline-container-6-4" class="outline-3">
<h3 id="sec-6-4"><span class="section-number-3">6.4</span> nsマクロ</h3>
<div class="outline-text-3" id="text-6-4">

<p>実際には、useやrequireはnsマクロないで使用する。
上で説明したものは関数だが、nsマクロないのuse&amp;requireはキーワード(マクロ)である。
したがって、ベクタやリストをクオートする必要はない。
※マクロは関数でないのでリストは評価されないため。
</p>



<pre class="src src-sh">(ns strike-witches.core
  (:use
   [clojure.pprint :only (pprint pp)]
   (clojure.contrib
    (classpath :only (classpath))
    (macro-utils :only (macrolet))))
  (:require
   :reload-all
   (strike-witches
    (eila-ilmatar-juutilainen :as eila)
    (alexandra-urajimirovuna-ritovuyaku :as sanya))))
</pre>


</div>

</div>

<div id="outline-container-6-5" class="outline-3">
<h3 id="sec-6-5"><span class="section-number-3">6.5</span> </h3>
<div class="outline-text-3" id="text-6-5">




<pre class="src src-sh">(ns hello-cube.core)
(import (javax.swing JFrame))
</pre>


</div>
</div>

</div>

<div id="outline-container-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> slime</h2>
<div class="outline-text-2" id="text-7">

<p>カレントディレクトリは、多分replを起動したディレクトリ。
(clojure.contrib.duck-streams/pwd)関数で確認できる。
</p>
<p>
標準関数も以下で確認できる。
M-. タグジャンプ
M-, タグジャンプもどり
</p>
</div>

</div>

<div id="outline-container-8" class="outline-2">
<h2 id="sec-8"><span class="section-number-2">8</span> switch-caseの代替(複数分岐)</h2>
<div class="outline-text-2" id="text-8">




<pre class="src src-sh">(cond
    (= x :hey) <span class="org-string">"Hey!"</span>
    (= x :bye) <span class="org-string">"Bye!"</span>
    (= x :hi) <span class="org-string">"Hi!"</span>))
</pre>



<pre class="src src-sh">user&gt; (def foo <span class="org-comment-delimiter">#</span><span class="org-comment">(cond (= % 1) "1" (= % 2) "2"))</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">'user/foo</span>
user&gt; (foo 1)
<span class="org-string">"1"</span>
user&gt; (foo 2)
<span class="org-string">"2"</span>
user&gt; (foo 3)
nil
</pre>


<p>
その他に当たる部分は:else節を使用する。
</p>


<pre class="src src-sh">user&gt; (def foo <span class="org-comment-delimiter">#</span><span class="org-comment">(cond (= % 1) "1" (= % 2) "2" :else "other"))</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">'user/foo</span>
user&gt; (foo 1)
<span class="org-string">"1"</span>
user&gt; (foo 2)
<span class="org-string">"2"</span>
user&gt; (foo 3)
<span class="org-string">"other"</span>
</pre>



</div>

</div>

<div id="outline-container-9" class="outline-2">
<h2 id="sec-9"><span class="section-number-2">9</span> 正規表現</h2>
<div class="outline-text-2" id="text-9">

<p>正規表現リテラルがある。
</p>


<pre class="src src-sh"><span class="org-comment-delimiter">#</span><span class="org-comment">"pattern"</span>
</pre>

<p>
patternないでは\エスケープ剃る必要がない。
つまり
</p>


<pre class="src src-sh"><span class="org-comment-delimiter">#</span><span class="org-comment">"\s+"</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">"\w+"</span>
</pre>

<p>
てな感じでかける。
</p>
<p>
実際にマッチさせるにはre-seq関数を使用する。
</p>
<p>
グループ化
</p>


<pre class="src src-sh">user&gt; (re-seq <span class="org-comment-delimiter">#</span><span class="org-comment">"(\d)(\d+)" "123 abc 456 def") </span>
([<span class="org-string">"123"</span> <span class="org-string">"1"</span> <span class="org-string">"23"</span>] [<span class="org-string">"456"</span> <span class="org-string">"4"</span> <span class="org-string">"56"</span>])
</pre>

<p>
０番目に全体、残りにグループ化したものが入る。
</p>

</div>

</div>

<div id="outline-container-10" class="outline-2">
<h2 id="sec-10"><span class="section-number-2">10</span> use</h2>
<div class="outline-text-2" id="text-10">

<p>contrib.stringをuseしたら下記のようなワーニングが発生。
</p>


<pre class="src src-sh">user&gt; (use <span class="org-string">'clojure.contrib.string)</span>
<span class="org-string">WARNING: repeat already refers to: #'</span>clojure.core/repeat<span class="org-keyword"> in</span> namespace: user, being replaced by: <span class="org-comment-delimiter">#</span><span class="org-comment">'clojure.contrib.string/repeat^M</span>
WARNING: butlast already refers to: <span class="org-comment-delimiter">#</span><span class="org-comment">'clojure.core/butlast in namespace: user, being replaced by: #'clojure.contrib.string/butlast^M</span>
WARNING: reverse already refers to: <span class="org-comment-delimiter">#</span><span class="org-comment">'clojure.core/reverse in namespace: user, being replaced by: #'clojure.contrib.string/reverse^M</span>
WARNING: get already refers to: <span class="org-comment-delimiter">#</span><span class="org-comment">'clojure.core/get in namespace: user, being replaced by: #'clojure.contrib.string/get^M</span>
WARNING: partition already refers to: <span class="org-comment-delimiter">#</span><span class="org-comment">'clojure.core/partition in namespace: user, being replaced by: #'clojure.contrib.string/partition^M</span>
WARNING: drop already refers to: <span class="org-comment-delimiter">#</span><span class="org-comment">'clojure.core/drop in namespace: user, being replaced by: #'clojure.contrib.string/drop^M</span>
WARNING: take already refers to: <span class="org-comment-delimiter">#</span><span class="org-comment">'clojure.core/take in namespace: user, being replaced by: #'clojure.contrib.string/take^M</span>
</pre>

<p>
名前空間が衝突している模様。contribのバージョンがまずいのかな？
project.cljには下記を指定している。
</p>


<pre class="src src-sh">(defproject log-clj <span class="org-string">"1.0.0-SNAPSHOT"</span>
  :description <span class="org-string">"FIXME: write description"</span>
  :dependencies [[org.clojure/clojure <span class="org-string">"1.2.1"</span>]
                 [org.clojure/clojure-contrib <span class="org-string">"1.2.0"</span>]
                 ]
  :main log-clj.core)
</pre>

<p>
ver.1.2.0はまずいのかな。
</p>


</div>

</div>

<div id="outline-container-11" class="outline-2">
<h2 id="sec-11"><span class="section-number-2">11</span> lein</h2>
<div class="outline-text-2" id="text-11">

<p>下記で新規作成
$ lein new hoge
</p>
<p>
メイン関数をつくることで実行できる。
</p>


<pre class="src src-sh">$ vi src/hoge/core.clj 

(ns hoge.core
  (:gen-class))

(defn -main []
  (println <span class="org-string">"hoge..."</span>))
</pre>

<p>
ns関数の :gen-classはこのnamespaceでJavaクラスを作るという意味。
この場合、hoge.coreというJavaクラスを生成する。
</p>
<p>
これを実行するには、以下のようにrunコマンドでmain関数を-mオプションで指定する。
</p>


<pre class="src src-sh">$ lein run -m hoge.core
hoge
</pre>



<p>
さらに-mを省略したい場合は以下のようにproject.cljにmainクラスを指定する。
</p>


<pre class="src src-sh">:main hoge.core
</pre>


<p>
以下実行結果。
</p>


<pre class="src src-sh">$ lein run
hoge
</pre>


<p>
さらにさらにできたプログラムを単独で動かすためには下記のコマンド
</p>


<pre class="src src-sh">$ lein uberjar
</pre>

<p>
このコマンド名覚えづらいよね。ウバジャー！
</p>
<p>
以下実行結果。
</p>


<pre class="src src-sh">$ java -jar hoge-1.0.0-SNAPSHOT-standalone.jar 
hoge...
</pre>


<p>
しかし、、、ハローワールドの実効時間が約6秒もかかるのはどうにかしたいすな。。。
</p>


<pre class="src src-sh">miki@miki-laptop:~/dev/programming-clojure$ time lein run 
hello!

real    0m5.997s
user    0m11.220s
sys 0m0.420s
</pre>




<p>
参考
<a href="http://docs.komagata.org/4817">http://docs.komagata.org/4817</a>
</p>

</div>

<div id="outline-container-11-1" class="outline-3">
<h3 id="sec-11-1"><span class="section-number-3">11.1</span> 実行形式のファイルにする</h3>
<div class="outline-text-3" id="text-11-1">

<p>windows限定だけど、exewrapを使えばexeファイル化できる。
<a href="http://www.ne.jp/asahi/web/ryo/exewrap/">http://www.ne.jp/asahi/web/ryo/exewrap/</a>
インストールは簡単で、パスの通った場所にexewrap.exeを配置するだけ。
</p>


<pre class="src src-sh">dos&gt; exewrap hoge-1.0.0-SNAPSHOT-standalone.jar 
</pre>

<p>
これで実行形式の.exeファイルができるので
</p>


<pre class="src src-sh">dos&gt; hoge-1.0.0-SNAPSHOT-standalone.exe
hoge...
</pre>

<p>
ちなみに実行ファイル形式にすると、サイズが小さくなったりする。すばらしい！
</p>

</div>
</div>

</div>

<div id="outline-container-12" class="outline-2">
<h2 id="sec-12"><span class="section-number-2">12</span> Tips</h2>
<div class="outline-text-2" id="text-12">


</div>

<div id="outline-container-12-1" class="outline-3">
<h3 id="sec-12-1"><span class="section-number-3">12.1</span> ファイルの読み出し</h3>
<div class="outline-text-3" id="text-12-1">

<p>素直にやるとこうだが
</p>


<pre class="src src-lisp">(import '(java.io BufferedReader FileInputStream InputStreamReader))
(<span class="org-keyword">let</span> [br (BufferedReader. (InputStreamReader. (FileInputStream. <span class="org-string">"rdic-io.clj"</span>)))]
  (println (. br readLine))
  (. br close))
</pre>


<p>
contribに関数があるらしい。
</p>


<pre class="src src-lisp">(use '[clojure.contrib.duck-streams (<span class="org-builtin">:only</span> reader)])
(with-open [r (reader <span class="org-string">"rdic-io.clj"</span>)]
  (println (. r readLine)))
</pre>


<p>
(let [lines (line-seq (reader "project.clj"))] (str lines))
</p>
<p>
参考
<a href="http://simultechnology.blendmix.jp/blog/archives/415">http://simultechnology.blendmix.jp/blog/archives/415</a>
<a href="http://d.hatena.ne.jp/trotr/20100228/1267341388">http://d.hatena.ne.jp/trotr/20100228/1267341388</a>
</p>



</div>
</div>

</div>

<div id="outline-container-13" class="outline-2">
<h2 id="sec-13"><span class="section-number-2">13</span> ドキュメントを見る</h2>
<div class="outline-text-2" id="text-13">

<p>関数名がしっかりわかってる場合。
</p>


<pre class="src src-lisp">user&gt; (doc str)
</pre>


<p>
関数名が曖昧な場合。引数は文字列。
</p>


<pre class="src src-lisp">user&gt; (find-doc <span class="org-string">"str"</span>)
</pre>



</div>

</div>

<div id="outline-container-14" class="outline-2">
<h2 id="sec-14"><span class="section-number-2">14</span> JAVA</h2>
<div class="outline-text-2" id="text-14">


</div>

<div id="outline-container-14-1" class="outline-3">
<h3 id="sec-14-1"><span class="section-number-3">14.1</span> インポート</h3>
<div class="outline-text-3" id="text-14-1">

<p>user&gt; (import '(java.util Random Locale) '(java.text MessageFormat))
</p>
</div>

</div>

<div id="outline-container-14-2" class="outline-3">
<h3 id="sec-14-2"><span class="section-number-3">14.2</span> javaとの連携方法</h3>
<div class="outline-text-3" id="text-14-2">

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col class="left" /><col class="left" /><col class="left" />
</colgroup>
<tbody>
<tr><td class="left">Java</td><td class="left">Clojure(基本構文)</td><td class="left">Clojure(構文糖衣)</td></tr>
<tr><td class="left">new Widget("red")</td><td class="left">(new Widget "red")</td><td class="left">(Widget. "red")</td></tr>
<tr><td class="left">Math.PI</td><td class="left">(. Math PI)</td><td class="left">Math/PI</td></tr>
<tr><td class="left">System.currentTimeMillis()</td><td class="left">(. System currentTimeMillis)</td><td class="left">(System/currentTimeMillis)</td></tr>
<tr><td class="left">rnd.nextInt()</td><td class="left">(. rnd nextInt)</td><td class="left">(.nextInt rnd)</td></tr>
<tr><td class="left">person.getAddress().getZipCode()</td><td class="left">(. (. person getAddress) getZipCode)</td><td class="left">(.. person getAddress getZipCode</td></tr>
</tbody>
</table>



<p>
基本はドット関数。この本では構文糖衣を積極的に使うように推奨している。
</p>
</div>

</div>

<div id="outline-container-14-3" class="outline-3">
<h3 id="sec-14-3"><span class="section-number-3">14.3</span> javaのインターフェイスを実装する方法</h3>
<div class="outline-text-3" id="text-14-3">

<p>proxyをつかう
</p>
<p>
clojure.core/proxy
([class-and-interfaces args &amp; fs])
</p>
<p>
最初に引数にスーパークラスまたはインターフェイスを指定する。
2番目の引数には最初のクラス（インタフェイス）へのコンストラクタの引数を指定する。
</p>

</div>
</div>

</div>

<div id="outline-container-15" class="outline-2">
<h2 id="sec-15"><span class="section-number-2">15</span> リーダーマクロ</h2>
<div class="outline-text-2" id="text-15">

<p>表記を簡単にするためのシンタックスシュガー
</p><table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">
<caption></caption>
<colgroup><col class="left" /><col class="left" />
</colgroup>
<tbody>
<tr><td class="left">無名関数</td><td class="left">#(.toUpperCase %)</td></tr>
<tr><td class="left">コメント</td><td class="left">;single-line comment</td></tr>
<tr><td class="left">参照外し(deref)</td><td class="left">@form =&gt; (deref form)</td></tr>
<tr><td class="left">メタ</td><td class="left"><sup>form</sup> =&gt; (meta form)</td></tr>
<tr><td class="left">メタデータ</td><td class="left">#<sup>metadata</sup> form</td></tr>
<tr><td class="left">クオート</td><td class="left">'form =&gt; (quote form)</td></tr>
<tr><td class="left">正規表現パターン</td><td class="left">#"foo"   =&gt; a</td></tr>
<tr><td class="left">構文クオート</td><td class="left">'x</td></tr>
<tr><td class="left">アンクオート</td><td class="left">~</td></tr>
<tr><td class="left">スプライシングアンクオート</td><td class="left">~@</td></tr>
<tr><td class="left">varクオート</td><td class="left">#'x =&gt; (var x)</td></tr>
</tbody>
</table>



</div>

</div>

<div id="outline-container-16" class="outline-2">
<h2 id="sec-16"><span class="section-number-2">16</span> 変数の変更</h2>
<div class="outline-text-2" id="text-16">


<p>
変更可能の変数
(def current-track (ref "Mars, the Bringer of War"))
current-trackの変更可能な参照を作成する。
より軽量な変数をつかいたければアトムを使用する。
(def current-track (atom "Mars, the Bringer of War"))
</p>
<p>
参照するには
(deref current-track)
or
@current-track
</p>
<p>
変更するには
ref-set
だが、これは直接利用できない。下記のようにdosyncでかこむひつようがある。
(dosync (ref-set current-track "Venus, the Bringer of Peace"))
</p>
<p>
データの一部を変更する場合（リストの中のS式をさしかえるなど）
更新前のmessagesをconjの第一引数にわたしてmsgをmessagesに追加する。
(dosync (alter messages conj msg)))
</p>
</div>

</div>

<div id="outline-container-17" class="outline-2">
<h2 id="sec-17"><span class="section-number-2">17</span> ライブラリのロード</h2>
<div class="outline-text-2" id="text-17">

<p>(require 'clojure.contrib.str-utils)
</p>
<p>
この場合、CLASSPATHで指定したディレクトリのどこかに
${CLASSPATH-ROOT}/clojure/contrib/str-utils.clj
というファイルがなくてはならないらしい。
また、requireだけだと利用時に完全修飾しなくてはならないので
最後のライブラリ名だけで利用したければreferを使う。
(refer 'clojure.contrib.str-utils)
</p>
<p>
なので実際には下記2行を書く必要がある。
(require 'clojure.contrib.str-utils)
(refer 'clojure.contrib.str-utils)
</p>
<p>
ただし2行書くのは面倒なので普通は、useを使う。
(use 'clojure.contrib.str-utils)
</p>
</div>

</div>

<div id="outline-container-18" class="outline-2">
<h2 id="sec-18"><span class="section-number-2">18</span> 真偽</h2>
<div class="outline-text-2" id="text-18">

<p>javaと同じで、true, falseを使う。
nilとfalseのみが偽。
それ以外は真。
</p>
</div>

</div>

<div id="outline-container-19" class="outline-2">
<h2 id="sec-19"><span class="section-number-2">19</span> マップ</h2>
<div class="outline-text-2" id="text-19">

<p>{key value &hellip;}カッコを使う。
{"HOGE" "hoge" "FUGA" "fuga"}
上の場合、"HOGE", "FUGA"がキーになる。
でも普通はキーワードを使う。
user=&gt; (def hoges {:HOGE "hoge" :FUGA "fuga"})
</p>
<p>
値の取り出し方。
user=&gt; (hoges :HOGE)
"hoge"
user=&gt; (:HOGE hoges)
"hoge"
</p>
<p>
assoc
</p>

</div>

</div>

<div id="outline-container-20" class="outline-2">
<h2 id="sec-20"><span class="section-number-2">20</span> 関数</h2>
<div class="outline-text-2" id="text-20">

<p>(defun [args*] expr*) 
引数の数は厳密にチェックされる。実引数と仮引数の数が違うとエラーになる。
</p>
<p>
可変引数は、引数の前に「＆」をつける。
user=&gt; (defn date [person-1 person-2 &amp; chapersons]
         (println person-1 "and" person-2 "went out with " (count chapersons) "chapersons."))
user=&gt; (date "hoge" "huga" "piyo" "hage")
hoge and huga went out with  2 chapersons.
nil
</p>
<p>
名前が同じで引数の数の違う関数を定義することもできる。
</p>


<pre class="src src-sh"><span class="org-variable-name">user</span>=&gt; (defn greeting
         ([] (greeting <span class="org-string">"world"</span>))
         ([username] (str <span class="org-string">"Hello, "</span> username)))
<span class="org-variable-name">user</span>=&gt; (greeting)
<span class="org-string">"Hello, world"</span>
</pre>



</div>

<div id="outline-container-20-1" class="outline-3">
<h3 id="sec-20-1"><span class="section-number-3">20.1</span> 無名関数</h3>
<div class="outline-text-3" id="text-20-1">


<p>
無名関数は次のように定義する。
</p>


<pre class="src src-sh">(fn [] body)
<span class="org-comment-delimiter">#</span><span class="org-comment">(body)</span>
</pre>

<p>
「#()」の形式では、%1,%2で引数を参照でき、%で最初の引数を参照する。
</p>


</div>

<div id="outline-container-20-1-1" class="outline-4">
<h4 id="sec-20-1-1"><span class="section-number-4">20.1.1</span> はまり</h4>
<div class="outline-text-4" id="text-20-1-1">

<p>無名関数の本体はそれ自身がフォームというか全体を返さなければならない。
たとえば0から9の数値のリストを返す関数を定義する場合。
</p>


<pre class="src src-sh"><span class="org-comment-delimiter">#</span><span class="org-comment">((range 10))</span>
</pre>

<p>
ではうまくいかない。
カッコをひとつ減らして書かなくてはならない。
</p>


<pre class="src src-sh"><span class="org-comment-delimiter">#</span><span class="org-comment">(range 10)</span>
</pre>


<p>
"#"で始まるカッコは無名関数と覚えよう。
３で割り切れる時に"fizz"を帰す場合if文。
(if (= (mod % 3) 0) "fizz" %)
これに＃をつければ無名関数になる
</p>


<pre class="src src-sh">user&gt; (def foo <span class="org-comment-delimiter">#</span><span class="org-comment">(if (= (mod % 3) 0) "fizz" %))</span>
<span class="org-comment-delimiter">#</span><span class="org-comment">'user/foo</span>
user&gt; (foo 3)
<span class="org-string">"fizz"</span>
user&gt; (foo 1)
1
</pre>




</div>
</div>
</div>

</div>

<div id="outline-container-21" class="outline-2">
<h2 id="sec-21"><span class="section-number-2">21</span> 束縛</h2>
<div class="outline-text-2" id="text-21">

<p>(def foo 10)
このときfooは10に束縛される。
</p>
<p>
var関数は名前そのものを返す。
(var foo)
簡易形式。
</p>

</div>

<div id="outline-container-21-1" class="outline-3">
<h3 id="sec-21-1"><span class="section-number-3">21.1</span> ひとこと</h3>
<div class="outline-text-3" id="text-21-1">

<p>lispを習う上で障害となるものに用語があると思うんだけどそのひとつに束縛という用語があると思う。
なぜ代入じゃなくて束縛なんだと。
代入みたいなもんだと思って説明を読み進めるけど
束縛ということばが出てくるたびに、それが引っかかって理解を妨げる気がする。
そんな「束縛」という言葉だけども、関数言語の勉強をしタお陰でやっと理解できた気がする。
従来の手続き型言語だと、変数の説明のときに
箱をイメージしてその中に値をいれる図がでてくる。
だけれども束縛の場合は名札を用意して値にそれをつけるイメージだということ。
手続き言語だと変数が主役で
関数言語だと値が主役ということですね。
</p>

</div>
</div>

</div>

<div id="outline-container-22" class="outline-2">
<h2 id="sec-22"><span class="section-number-2">22</span> 分配束縛</h2>
<div class="outline-text-2" id="text-22">

<p>たとえばmapを引数にした関数があった場合、
引数のバインドに必要なキーだけ定義しておけば
いちいちmap全体をバインドせずともそのキーのあたいだけをいきなり持ってこれる。
</p>
<p>
こっちは分配束縛なし版
user=&gt; (defn greet-author-1 [author]
         (println "Hello," (:first-name author)))
user=&gt; (greet-author-1 {:last-name "Vinge" :first-name "Vernor"})
Hello, Vernor
</p>
<p>
こっちは分配束縛あり
user=&gt; (defn greet-author-2 [{fname :first-name}]
         (println "Hello, " fname))
user=&gt; (greet-author-2 {:last-name "Vinge" :first-name "Vernor"})
Hello,  Vernor
</p>
<p>
ベクタの場合
(let [[x y] [1 2 3]] [x y])
=&gt; [1 2]
</p>
<p>
(let [[_ _ z] [1 2 3]] z)
=&gt; 3
</p>
<p>
:as節を使えばベクタ全体も束縛することができる。
</p>
<p>
(let [[x y :as coords] [1 2 3 4 5 6]]
            (str "x:" x " y:" y "dims:" (count coords)))
</p>



</div>

</div>

<div id="outline-container-23" class="outline-2">
<h2 id="sec-23"><span class="section-number-2">23</span> シーケンス</h2>
<div class="outline-text-2" id="text-23">


</div>

<div id="outline-container-23-1" class="outline-3">
<h3 id="sec-23-1"><span class="section-number-3">23.1</span> 指定した番目の要素を取得する。</h3>
<div class="outline-text-3" id="text-23-1">




<pre class="src src-sh">(nth <span class="org-string">'(1 2 3) 0) ; =&gt; 1</span>
<span class="org-string">(nth '</span>(1 2 3) 1) ; =&gt; 2
(nth <span class="org-string">'(1 2 3) 2) ; =&gt; 3</span>
<span class="org-string">(nth '</span>(1 2 3) 3) ; Thrown class java.lang.IndexOutOfBoundsException
(nth <span class="org-string">'(1 2 3) 3 nil) ; =&gt; nil</span>

<span class="org-string">(get '</span>(1 2 3) 0) ; =&gt; 1
(get <span class="org-string">'(1 2 3) 1) ; =&gt; 2</span>
<span class="org-string">(get '</span>(1 2 3) 2) ; =&gt; 3
(get <span class="org-string">'(1 2 3) 3) ; =&gt; nil</span>
</pre>


</div>

</div>

<div id="outline-container-23-2" class="outline-3">
<h3 id="sec-23-2"><span class="section-number-3">23.2</span> 変換</h3>
<div class="outline-text-3" id="text-23-2">

<p>入力と出力ともにシーケンスを使う関数たち。
</p>

</div>

<div id="outline-container-23-2-1" class="outline-4">
<h4 id="sec-23-2-1"><span class="section-number-4">23.2.1</span> map</h4>
<div class="outline-text-4" id="text-23-2-1">

<p>一番簡単な変換関数。
</p>


<pre class="src src-sh">user&gt; (map  <span class="org-comment-delimiter">#</span><span class="org-comment">(format "&lt;p&gt;%s&lt;/p&gt;" %) ["the" "quick" "brown" "fox"])</span>
(<span class="org-string">"&lt;p&gt;the&lt;/p&gt;"</span> <span class="org-string">"&lt;p&gt;quick&lt;/p&gt;"</span> <span class="org-string">"&lt;p&gt;brown&lt;/p&gt;"</span> <span class="org-string">"&lt;p&gt;fox&lt;/p&gt;"</span>)
</pre>


</div>

</div>

<div id="outline-container-23-2-2" class="outline-4">
<h4 id="sec-23-2-2"><span class="section-number-4">23.2.2</span> reduce</h4>
<div class="outline-text-4" id="text-23-2-2">

<p>引数を２つとって、順番に関数を適用していくが、その結果を次の結果に渡していく。
</p>


<pre class="src src-sh">user&gt; (reduce + (range 11))
 55
</pre>


</div>

</div>

<div id="outline-container-23-2-3" class="outline-4">
<h4 id="sec-23-2-3"><span class="section-number-4">23.2.3</span> sort, sort-by</h4>
<div class="outline-text-4" id="text-23-2-3">




<pre class="src src-sh">user&gt; (sort [5 2 1 3 4])
 (1 2 3 4 5)
</pre>


<p>
sort-by
</p>


<pre class="src src-sh">user&gt; (sort-by <span class="org-comment-delimiter">#</span><span class="org-comment">(.toString %) [42 1 7 11])</span>
 (1 11 42 7)
</pre>

<p>
.toStringにより文字列としてソートされる。したがって、7より42のほうが小さい。
</p>

<p>
ソートの順序を変えたければ、sortにもsort-byにも比較関数compを渡すことができる。
</p>


<pre class="src src-sh">(sort &gt; [42 1 7 11])
 (42 11 7 1)

user&gt; (sort-by :grade &gt; [{:grade 83} {:grade 90} {:grade 77}])
({:grade 90} {:grade 83} {:grade 77})
</pre>


</div>

</div>

<div id="outline-container-23-2-4" class="outline-4">
<h4 id="sec-23-2-4"><span class="section-number-4">23.2.4</span> for</h4>
<div class="outline-text-4" id="text-23-2-4">

<p>リストの内包表記というらしい（たぶん関数用語）。
一般的なfor文とは無関係。
forはマクロ。
リストを返す。
</p>



<pre class="src src-sh">&#27083;&#25991;
(<span class="org-keyword">for</span> [binding-form coll-expr filter-expr? ...] expr)
&#8251;... &#12399;&#12381;&#12428;&#20197;&#21069;&#12398;&#37096;&#20998;&#12398;&#32368;&#12426;&#36820;&#12375;&#12434;&#24847;&#21619;&#12377;&#12427;&#12290;
</pre>

<p>
A) binding-form(入力リストの各要素に束縛される、プレースホルダとなる変数)
B) coll-expr(入力となるリスト(複数可))
C) filter-expr?(要素に適用する述語)
D) expr(要素を満たす入力リストの要素から、出力リストの要素を作り出すための式)
</p>




<pre class="src src-sh">user&gt; (<span class="org-keyword">for</span> [word [<span class="org-string">"the"</span> <span class="org-string">"quick"</span> <span class="org-string">"brown"</span> <span class="org-string">"fox"</span>]] (format <span class="org-string">"&lt;p&gt;%s&lt;/p&gt;"</span> word))
(<span class="org-string">"&lt;p&gt;the&lt;/p&gt;"</span> <span class="org-string">"&lt;p&gt;quick&lt;/p&gt;"</span> <span class="org-string">"&lt;p&gt;brown&lt;/p&gt;"</span> <span class="org-string">"&lt;p&gt;fox&lt;/p&gt;"</span>)
</pre>

<p>
英語っぽくよめるらしい。
"For [each] word in [a sequence of words] format [according to format instructions]."
</p>
<p>
「C) filter-expr」として:when節がある。
</p>


<pre class="src src-sh">user&gt; (take 10 (<span class="org-keyword">for</span> [n (whole-numbers) :when (even? n)] n))
</pre>

<p>
whole-numbersが解決できなかったのでrangeで代用。
</p>



<pre class="src src-sh">user&gt; (take 10 (<span class="org-keyword">for</span> [n (range 100) :when (even? n)] n))
 (0 2 4 6 8 10 12 14 16 18)
</pre>


</div>
</div>
</div>

</div>

<div id="outline-container-24" class="outline-2">
<h2 id="sec-24"><span class="section-number-2">24</span> 実践例</h2>
<div class="outline-text-2" id="text-24">



</div>

<div id="outline-container-24-1" class="outline-3">
<h3 id="sec-24-1"><span class="section-number-3">24.1</span> ある文字列の値を足しこむ関数</h3>
<div class="outline-text-3" id="text-24-1">




<pre class="src src-sh">/**
 * &#25968;&#20516;&#36275;&#12375;&#31639;&#12513;&#12477;&#12483;&#12489;&#12290;&#24341;&#25968;&#12398;&#25968;&#20516;&#12398;&#12415;&#12434;&#36275;&#12375;&#31639;&#12289;&#32080;&#26524;&#12434;&#36820;&#12377;&#12290;
 * @param   String str &#25968;&#20516;&#20837;&#12426;&#25991;&#23383;&#21015;
 * @return  int &#21152;&#31639;&#28168;&#12415;&#25968;
 */
private static int addupEachDigit(String str) {
    <span class="org-keyword">if</span> (str == null || str.length() == 0) {
        <span class="org-keyword">return</span> 0;
    }
    int sum = 0;
    <span class="org-keyword">for</span> (int i = 0; i &lt; str.length(); i++) {
        char c = str.charAt(i);
        sum += c;
    }
    <span class="org-keyword">return</span> sum;
}
</pre>


<p>
まずCharの配列をつくる。
</p>


<pre class="src src-sh">user&gt; (.toCharArray <span class="org-string">"hoge"</span>)
<span class="org-comment-delimiter">#</span><span class="org-comment">&lt;char[] [C@171bc3f&gt;</span>
</pre>


<p>
と思ったら、APIがあった。
</p>


<pre class="src src-sh">user&gt; (char-array <span class="org-string">"hoge"</span>)
<span class="org-comment-delimiter">#</span><span class="org-comment">&lt;char[] [C@101ea1e&gt;</span>
</pre>


<p>
でこれをシーケンスにする。
</p>


<pre class="src src-sh">user&gt; (seq (char-array <span class="org-string">"hoge"</span>))
(\h \o \g \e)
</pre>


<p>
これにmapを適用してもうまくいかない。
</p>


<pre class="src src-sh">user&gt; (reduce + (\h \o \g \e))
; Evaluation aborted.
</pre>


<p>
charを数値にする必要があるっぽい。
APIでint関数見つけた。
</p>


<pre class="src src-sh">user&gt; (int \c)
99
</pre>


<p>
で、charシーケンスを数値シーケンスに変換してみる。
</p>


<pre class="src src-sh">user&gt; (map int <span class="org-string">'(\h \o \g \e)) </span>
<span class="org-string">(104 111 103 101)</span>
</pre>


<p>
できた！でこれをreduce似適用し見る。
</p>


<pre class="src src-sh">user&gt;
419
</pre>


<p>
今までのを全部統合して完成。文字を数値化して足し込む。
</p>


<pre class="src src-sh">user&gt; (reduce + (map int (seq (char-array <span class="org-string">"hoge"</span>))))
419
</pre>


<p>
最終的に完成したコード
</p>


<pre class="src src-sh">&#12371;&#12428;&#12364;
  private static int addupEachDigit(String str) {
      <span class="org-keyword">if</span> (str == null || str.length() == 0) {
          <span class="org-keyword">return</span> 0;
      }
      int sum = 0;
      <span class="org-keyword">for</span> (int i = 0; i &lt; str.length(); i++) {
          char c = str.charAt(i);
          sum += c;
      }
      <span class="org-keyword">return</span> sum;
  }

&#12371;&#12358;&#12394;&#12387;&#12383;&#12290;&#12290;&#12290;
(defn summarize-chars [s]
  (reduce + (map int (seq (char-array s))))
  )
</pre>



<pre class="src src-sh">user&gt; (summarize-chars <span class="org-string">""</span>)
0
user&gt; (summarize-chars <span class="org-string">'())</span>
<span class="org-string">0</span>
<span class="org-string">user&gt; (summarize-chars nil)</span>
<span class="org-string">0</span>
</pre>



</div>

</div>

<div id="outline-container-24-2" class="outline-3">
<h3 id="sec-24-2"><span class="section-number-3">24.2</span> みんな大好きfizzbuzz</h3>
<div class="outline-text-3" id="text-24-2">




<pre class="src src-sh">(def fb <span class="org-comment-delimiter">#</span><span class="org-comment">(for [x (rest (range (+ % 1)))] (cond (and (= 0 (mod x 3) (= 0 (mod x 5)))) "bf" (= 0 (mod x 3)) "f" (= 0 (mod x 5)) "b" :else x)))</span>
</pre>


<p>
ムダが多すぎる。
</p>


<pre class="src src-lisp">(def fb #(for [x (range 1 (+ % 1))] (<span class="org-keyword">cond</span> (= 0 (mod x 15)) <span class="org-string">"bf"</span> (= 0 (mod x 3)) <span class="org-string">"f"</span> (= 0 (mod x 5)) <span class="org-string">"b"</span> <span class="org-builtin">:else</span> x)))
</pre>


<p>
(def fb #(for [x (range 1 (+ % 1))] ))
</p>
<p>
(defn [n] (map #(cond (= 0 (mod % 15)) "bf" (= 0 (mod % 3)) "f" (= 0 (mod % 5)) "b" :else %) (range 1 (+ n 1)))) 
</p>

<p>
; SLIME 2011-08-26
user&gt; (doc range)

</p>
<hr/>
<p>
clojure.core/range
([] [end] [start end] [start end step])
  Returns a lazy seq of nums from start (inclusive) to end
  (exclusive), by step, where start defaults to 0, step to 1, and end
  to infinity.
nil
user&gt; (use 'hello-cube.core)
nil
user&gt; 
nil
user&gt; 
nil
user&gt; 
nil
user&gt; (print (fizzbuzz 10))
 (print (fizzbuzz 10))
</p>
<p>
nil
user&gt; (fizzbuzz 10)
</p>
<p>
nil
user&gt; (use :reload 'hello-cube.core)
nil
user&gt; (fizzbuzz 10)
(0 1 2 3 4 5 6 7 8 9)
user&gt; (doc for)

</p>
<hr/>
<p>
clojure.core/for
([seq-exprs body-expr])
Macro
  List comprehension. Takes a vector of one or more
   binding-form/collection-expr pairs, each followed by zero or more
   modifiers, and yields a lazy sequence of evaluations of expr.
   Collections are iterated in a nested fashion, rightmost fastest,
   and nested coll-exprs can refer to bindings created in prior
   binding-forms.  Supported modifiers are: :let [binding-form expr &hellip;],
   :while test, :when test.
</p>
<p>
  (take 100 (for [x (range 100000000) y (range 1000000) :while (&lt; y x)] [x y]))
nil
user&gt; (take 100 (for [x (range 100000000) y (range 1000000) :while (&lt; y x)] [x y]))
([1 0] [2 0] [2 1] [3 0] [3 1] [3 2] [4 0] [4 1] [4 2] [4 3] [5 0] [5 1] [5 2] [5 3] [5 4] [6 0] [6 1] [6 2] [6 3] [6 4] [6 5] [7 0] [7 1] [7 2] [7 3] [7 4] [7 5] [7 6] [8 0] [8 1] [8 2] [8 3] [8 4] [8 5] [8 6] [8 7] [9 0] [9 1] [9 2] [9 3] [9 4] [9 5] [9 6] [9 7] [9 8] [10 0] [10 1] [10 2] [10 3] [10 4] [10 5] [10 6] [10 7] [10 8] [10 9] [11 0] [11 1] [11 2] [11 3] [11 4] [11 5] [11 6] [11 7] [11 8] [11 9] [11 10] [12 0] [12 1] [12 2] [12 3] [12 4] [12 5] [12 6] [12 7] [12 8] [12 9] [12 10] [12 11] [13 0] [13 1] [13 2] [13 3] [13 4] [13 5] [13 6] [13 7] [13 8] [13 9] [13 10] [13 11] [13 12] [14 0] [14 1] [14 2] [14 3] [14 4] [14 5] [14 6] [14 7] [14 8])
user&gt; (for [x (range 10)] [x])
(<sup><a class="footref" name="fnr.1" href="#fn.1">1</a></sup> <sup><a class="footref" name="fnr.2" href="#fn.2">2</a></sup> <sup><a class="footref" name="fnr.3" href="#fn.3">3</a></sup> <sup><a class="footref" name="fnr.4" href="#fn.4">4</a></sup> <sup><a class="footref" name="fnr.5" href="#fn.5">5</a></sup> <sup><a class="footref" name="fnr.6" href="#fn.6">6</a></sup> <sup><a class="footref" name="fnr.7" href="#fn.7">7</a></sup> <sup><a class="footref" name="fnr.8" href="#fn.8">8</a></sup> <sup><a class="footref" name="fnr.9" href="#fn.9">9</a></sup> <sup><a class="footref" name="fnr.10" href="#fn.10">10</a></sup>)
user&gt; (for [x (range 10)] x)
(0 1 2 3 4 5 6 7 8 9)
user&gt; <sup><a class="footref" name="fnr.2.2" href="#fn.2">2</a></sup>
nil
user&gt; (use :reload 'hello-cube.core)
nil
user&gt; (fizzbuzz 10)
(0 1 2 3 4 5 6 7 8 9)
user&gt; (doc mod)

</p>
<hr/>
<p>
clojure.core/mod
([num div])
  Modulus of num and div. Truncates toward negative infinity.
nil
user&gt; (doc =)

</p>
<hr/>
<p>
clojure.core/=
([x] [x y] [x y &amp; more])
  Equality. Returns true if x equals y, false if not. Same as
  Java x.equals(y) except it also works for nil, and compares
  numbers and collections in a type-independent manner.  Clojure's immutable data
  structures define equals() (and thus =) as a value, not an identity,
  comparison.
nil
user&gt; (mod 10 3)
1
user&gt; (mod 3 3)
0
user&gt; (= (mod 3 3) 0) 
true
user&gt; (if (= (mod 3 3) 0) "fizz") 
"fizz"
user&gt; (if (= (mod 4 3) 0) "fizz") 
nil
user&gt; (if (= (mod 4 3) 0) "fizz" 4) 
4
user&gt; (map #((if (= (mod 4 3) 0) "fizz" 4))  (range 10))
</p>

<p> 
nil
user&gt; (def hoge #((if (= (mod 4 3) 0) "fizz" 4)))
user&gt; (hoge)
</p>
<p>
nil
user&gt; '(hoge)
(hoge)
user&gt; (if (= (mod 4 3) 0) "fizz" 4)
4
user&gt; (hoge)
</p>
<p>
nil
user&gt; (if (= (mod 4 3) 0) "fizz" "aa")
"aa"
user&gt; (def hoge #((if (= (mod 4 3) 0) "fizz" "aa")))
user&gt; (hoge)
</p>
<p>
nil
user&gt; (def hoge #(1))
user&gt; 
nil
user&gt; (hoge)
</p>
<p>
nil
user&gt; (def hoge #((range 10)))
user&gt; (hoge)
</p>
<p>
nil
user&gt; (hoge)
</p>
<p>
nil
user&gt; (clojure-version)
"1.2.0"
user&gt; #(.toUpperCase %) 
user&gt; (def #(.toUpperCase %)) 
</p>
<p>
nil
user&gt; (def foo #(.toUpperCase %)) 
user&gt; (foo)
(foo )
</p>
<p>
nil
user&gt; (foo "aaa")
"AAA"
user&gt; (def foo #((if (= (mod 4 3) 0) "fizz" "aa")))
user&gt; (foo)
</p>
<p>
nil
user&gt; (if (= (mod 4 3) 0) "fizz" "aa")
"aa"
user&gt; #(if (= (mod 4 3) 0) "fizz" "aa")
user&gt; (def hoge #((range 10)))
user&gt; (def foo #(if (= (mod % 3) 0) "fizz" %))
user&gt; (foo 3)
"fizz"
user&gt; (foo 1)
1
user&gt; (use :reload 'hello-cube.core)
nil
user&gt; (fizzbuzz 10)
(0 1 2 3 4 5 6 7 8 9)
user&gt; 
("fizz" 1 2 "fizz" 4 5 "fizz" 7 8 "fizz")
user&gt; (for [x ((rest range) 10) ] (if (= (mod x 3) 0) "fizz" x)) ) ] (if (= (mod x 3) 0) "fizz" x)) 
) ] (if (= (mod x 3) 0) "fizz" x)) 
</p>
<p>
nil
user&gt; (for [x (rest (range 10)) ] (if (= (mod x 3) 0) "fizz" x)) ) ] (if (= (mod x 3) 0) "fizz" x))
</p>
<p>
nil
user&gt; (for [x (range 10)] (if (= (mod x 3) 0) "fizz" x))
("fizz" 1 2 "fizz" 4 5 "fizz" 7 8 "fizz")
user&gt; (for [x (rest (range 10)) ] (if (= (mod x 3) 0) "fizz" x))
(1 2 "fizz" 4 5 "fizz" 7 8 "fizz")
user&gt; (for [x (rest (range 10+1)) ] (if (= (mod x 3) 0) "fizz" x))
</p>
<p>
nil
user&gt; (for [x (rest (range (+ 10 1)))] (if (= (mod x 3) 0) "fizz" x))
(1 2 "fizz" 4 5 "fizz" 7 8 "fizz" 10)
user&gt; (def foo #(for [x (rest (range (+ % 1)))] (if (= (mod x 3) 0) "fizz" x)))
user&gt; (foo 10)
(1 2 "fizz" 4 5 "fizz" 7 8 "fizz" 10)
user&gt; (defn fizzbuzz [term]
  (for [x (range term) ] (if (= (mod x 3) 0) "fizz" x)) 
  )
</p>
<p>
nil
user&gt; (foo 100)
(1 2 "fizz" 4 5 "fizz" 7 8 "fizz" 10 11 "fizz" 13 14 "fizz" 16 17 "fizz" 19 20 "fizz" 22 23 "fizz" 25 26 "fizz" 28 29 "fizz" 31 32 "fizz" 34 35 "fizz" 37 38 "fizz" 40 41 "fizz" 43 44 "fizz" 46 47 "fizz" 49 50 "fizz" 52 53 "fizz" 55 56 "fizz" 58 59 "fizz" 61 62 "fizz" 64 65 "fizz" 67 68 "fizz" 70 71 "fizz" 73 74 "fizz" 76 77 "fizz" 79 80 "fizz" 82 83 "fizz" 85 86 "fizz" 88 89 "fizz" 91 92 "fizz" 94 95 "fizz" 97 98 "fizz" 100)
user&gt; (def foo #(for [x (rest (range (+ % 1)))] (if (and (= (mod x 3) 0) (= (mod x 5) 0)) "fizzbuzz" x)))
user&gt; (foo 100)
(1 2 3 4 5 6 7 8 9 10 11 12 13 14 "fizzbuzz" 16 17 18 19 20 21 22 23 24 25 26 27 28 29 "fizzbuzz" 31 32 33 34 35 36 37 38 39 40 41 42 43 44 "fizzbuzz" 46 47 48 49 50 51 52 53 54 55 56 57 58 59 "fizzbuzz" 61 62 63 64 65 66 67 68 69 70 71 72 73 74 "fizzbuzz" 76 77 78 79 80 81 82 83 84 85 86 87 88 89 "fizzbuzz" 91 92 93 94 95 96 97 98 99 100)
user&gt; 
nil
user&gt; 
nil
user&gt; (doc cond)
</p>
<p> 
nil
user&gt; (doc cond)

</p>
<hr/>
<p>
clojure.core/cond
([&amp; clauses])
Macro
  Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn't evaluate any of the
  other tests or exprs. (cond) returns nil.
nil
user&gt; (cond (= 1 1) 1)
1
user&gt; (def foo #(cond (= 1 1) "a" (= % 2)) "2")
</p>
<p>
nil
user&gt; (def foo #(cond (= 1 1) "1" (= % 2) "2"))
user&gt; (foo 1)
"a"
user&gt; (foo 2)
"a"
user&gt; (foo 3)
"a"
user&gt; (def foo #(cond (= 1 1) "1" (= % 2) "2"))
user&gt; (foo 1)
"1"
user&gt; (foo 2)
"1"
user&gt; 
nil
user&gt; (def foo #(cond (= % 1) "1" (= % 2) "2"))
user&gt; (foo 1)
"1"
user&gt; (foo 2)
"2"
user&gt; (foo 3)
nil
user&gt; (def foo #(cond (= % 1) "1" (= % 2) "2" "other"))
</p>
<p>
nil
user&gt; (doc cond)

</p>
<hr/>
<p>
clojure.core/cond
([&amp; clauses])
Macro
  Takes a set of test/expr pairs. It evaluates each test one at a
  time.  If a test returns logical true, cond evaluates and returns
  the value of the corresponding expr and doesn't evaluate any of the
  other tests or exprs. (cond) returns nil.
nil
user&gt; (def foo #(cond (= % 1) "1" (= % 2) "2" :else "other"))
user&gt; (foo 1)
"1"
user&gt; (foo 2)
"2"
user&gt; (foo 3)
"other"
(def foo #(for [x (rest (range (+ % 1)))] 
(cond
    (and (= 0 (mod x 3) (= 0 (mod x 5)) "bf"
    (= 0 (mod x 3)) "f"
    (= 0 (mod x 5)) "fb"
:else x
)
)
</p>
<p>
))
user&gt; 
nil
user&gt; (foo 10)
"other"
user&gt; (def foo #(for [x (rest (range (+ % 1)))] 
(cond
    (and (= 0 (mod x 3) (= 0 (mod x 5)) "bf"
    (= 0 (mod x 3)) "f"
    (= 0 (mod x 5)) "fb"
:else x
)
)
</p>
<p>
)))
</p>
<p>
nil
user&gt; (def fb #(for [x (rest (range (+ % 1)))] (cond (and (= 0 (mod x 3) (= 0 (mod x 5)))) "bf" (= 0 (mod x 3)) "f" (= 0 (mod x 5)) "b" :else x)))
</p>
<p>
user&gt; (fb 100)
(1 2 "f" 4 "b" "f" 7 8 "f" "b" 11 "f" 13 14 "f" 16 17 "f" 19 "b" "f" 22 23 "f" "b" 26 "f" 28 29 "f" 31 32 "f" 34 "b" "f" 37 38 "f" "b" 41 "f" 43 44 "f" 46 47 "f" 49 "b" "f" 52 53 "f" "b" 56 "f" 58 59 "f" 61 62 "f" 64 "b" "f" 67 68 "f" "b" 71 "f" 73 74 "f" 76 77 "f" 79 "b" "f" 82 83 "f" "b" 86 "f" 88 89 "f" 91 92 "f" 94 "b" "f" 97 98 "f" "b")
user&gt; 
</p>



<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">
<p class="footnote"><sup><a class="footnum" name="fn.1" href="#fnr.1">1</a></sup> DEFINITION NOT FOUND: 0
</p>

<p class="footnote"><sup><a class="footnum" name="fn.2" href="#fnr.2">2</a></sup> user&gt; (doc conj)

</p>
<hr/>
<p>
clojure.core/conj
([coll x] [coll x &amp; xs])
  conj[oin]. Returns a new collection with the xs
    'added'. (conj nil item) returns (item).  The 'addition' may
    happen at different 'places' depending on the concrete type.
nil
user&gt; (range 10)
(0 1 2 3 4 5 6 7 8 9)
user&gt; (use reload: 'hello-cube.core)
</p>

<p class="footnote"><sup><a class="footnum" name="fn.3" href="#fnr.3">3</a></sup> DEFINITION NOT FOUND: 2
</p>

<p class="footnote"><sup><a class="footnum" name="fn.4" href="#fnr.4">4</a></sup> DEFINITION NOT FOUND: 3
</p>

<p class="footnote"><sup><a class="footnum" name="fn.5" href="#fnr.5">5</a></sup> DEFINITION NOT FOUND: 4
</p>

<p class="footnote"><sup><a class="footnum" name="fn.6" href="#fnr.6">6</a></sup> DEFINITION NOT FOUND: 5
</p>

<p class="footnote"><sup><a class="footnum" name="fn.7" href="#fnr.7">7</a></sup> DEFINITION NOT FOUND: 6
</p>

<p class="footnote"><sup><a class="footnum" name="fn.8" href="#fnr.8">8</a></sup> DEFINITION NOT FOUND: 7
</p>

<p class="footnote"><sup><a class="footnum" name="fn.9" href="#fnr.9">9</a></sup> DEFINITION NOT FOUND: 8
</p>

<p class="footnote"><sup><a class="footnum" name="fn.10" href="#fnr.10">10</a></sup> DEFINITION NOT FOUND: 9
</p></div>
</div>
</div>

</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: 2012-02-17 20:08:20 JST</p>
<p class="author">Author: </p>
<p class="creator">Org version 7.8.03 with Emacs version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
